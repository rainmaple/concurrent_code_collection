## 类的加载过程

- 加载过程：找class文件
- 链接阶段
  - 验证class文件
  - 准备：静态变量分配内存，初始化默认值
  - 解析 ：类中符号引用转换成直接引用

- 初始化阶段：为静态变量赋予正确初始值

  JVM对类的初始化是一个延迟的机制Lazy,首次被使用时才会被初始化。

## 类的主动使用和被动使用

1. 主动

   - new关键字
   - 访问类的静态变量
   - 访问类的静态方法
   - 对类进行反射操作
   - 初始化子类(通过子类使用父类的静态变量，只会初始化父类)
   - 启动类main

2. 被动

   除了以上的主动方式，其余都是被动引用

**引用类的静态常量不会导致类的初始化（前提是这个静态常量不涉及复杂计算）**

#### 类的加载阶段

将class文件中的二进制数据读取到内存中，然后将字节流代表的静态存储结构转换成方法区中运行时的数据结构，并且在堆内存中生成一个该类的java.lang.Class对象,作为访问方法区数据结构的入口。

类加载的最终产物是堆内存中的class对象

虽然虚拟机规范中指出，类的加载是通过一个(包名+类名)来获取二进制数据流，但是没有限定何种方式去获取。

具体方式有：

- 运行时动态生成
- 网络获取
- 读取zip/jar/war获取类的二进制字节流
- 获取数据库中BLOB字段类型。
- 运行时生成class文件，动态加载，在某个Schema文件中生成若干class文件

#### 类的连接阶段

*在加载阶段没结束之前，连接其实已经可以开始了。*

1. 验证

   1. 验证文件格式
   2. 元数据验证
   3. 字节码验证
   4. 符号引用验证

2. 准备

   其实就是为对象的类变量静态变量，设置初始值。

   ```private static int a = 10;```  会初始化为0

   而```private final static int b = 10;``` 则会初始化为10

   是因为javac会将b的初始值生成一个ConstantValue属性，直接赋予10

### 类的初始化阶段

执行clinit方法中过程，所有的类变量都会赋予正确的值

clinit 为class initialize的所以写的，该方法包含了所有类变量的赋值动作和静态语句块的执行代码，在编译阶段由编译器按照源文件顺序收集。